---
title: We Programmers - A Retrospective
pubDate: '2025-04-13T17:26:05.000Z'
description: My thoughts on Robbert C. Martin's Book, We Programmers
layout: '../../layouts/BlogPost.astro'
---

There's a lot of worry right now in the software development industry. There's 
layoffs, AI is vying for all of our jobs, markets are unstable and there's no 
telling where the industry, let alone the world is going to look like over the 
next 10 to 20 years. Things are changing, and change is always unsettling. 
During moments like these, sometimes a look backward into how we got here, can 
offer insight into where things are going. 

I sit here, on a sunny spring day, the last day of my paternity leave, 
pondering the question of will I see a day where I can't support my brand new 
family doing a thing that I love, programming. If you listen to tech twitter, 
I'm already obsolete. A dying breed. I don't vibe code all day. I don't just 
give in and let the LLM cook while burning thousands of dollars in tokens. 
I'm not herding my band of agentic junior devs to the promised land of 
profitability. I care about the details in how software is written, and I 
enjoy the process of banging out code on a keyboard. It's meditative. Flow 
state is even addictive. I don't want to give that up to a soulless machine. 

While on leave I had a few small goals, and one of them was to finish a book, 
and I decided to pick up We Programmers by Robert C. Martin (aka. Uncle Bob) 
and read a little bit about computing history. I've always been interested in 
what predates my (relatively) young perspective into computing. I got my start 
on a Windows 98 machine playing old DOS games and aggravating my parents as I 
couldn't comprehend the concept of shutting down a machine vs just hitting the 
power button. I would inevitably corrupt the install, and someone more 
qualified than I would have to spend their day rebuilding the OS on the 
machine. Since my start, I'd always been fascinated by stories of the before. 
My Dad who was in college during a portion of these times, regaled a young me 
with stories of getting the mainframe to talk to the Macintosh, and then the 
Macintosh to talk to the PC to get remote sensing data from one place to the 
other. I always wondered what working in those sorts of mainframe environments 
were like. This book gave me exactly the insights I was looking for and much 
more. It starts with some of the earliest forms of computing with Babbage and 
Lovelace, and works its way all the way up to the point where Uncle Bob's own 
career started and it talks through possible permutations of the future. 

Walking through time, reading about how looping in programs actually started by 
physically looping paper tape, is mind boggling. Likewise the idea that these 
early machines broke often and produced erroneous results requiring debugging 
of the physical hardware and not just the software is also very humbling. In 
our modern age, we often don't even think about bits being flipped here and 
there, most of the time data arrives where it's supposed to, complete and 
uncorrupted in milliseconds. Early programs had to be optimized for the 
rotation of drum memory, saving data in tubes of mercury (sounds like black 
magic to me). All these things give me a bit more appreciation for the machine 
I use on a daily basis. 

One of the most remarkable takeaways to me though, is a thought that surfaces 
time and time again in my life, and a comfort in these turbulent times: there 
is nothing new under the sun. Machine architectures change, hardware gets 
better, software gets easier to write, and even through all this turmoil, 
someone still has to give machines directives. The more specific those 
directives the better. I think Uncle Bob puts it best when he calls programmers 
"Detail Managers." Even when you're giving instructions to an LLM, if you want 
things to be a certain way you need to be hyper specific and even then, if 
you're too specific the LLM seems to get confused and starts ignoring your 
directives and doing what it wants to instead. It's not thinking. It's not 
asking questions and making measured decisions based on the needs of users, 
it's just spitting out the path that most others have already tread. It's the 
average of all that came before and it can't come up with anything new, only 
mash old ideas together in potentially novel ways, and often those novel ways 
aren't even its doing, but the creative thinking of the prompter. 

I think that after reading this book, I've arrived at the conclusion that We 
Programmers aren't going anywhere any time soon. We just have a new tool in our 
tool belt. If anything, the acceleration in writing of software will just 
necessitate more creative minds dealing with the never ending problems and 
features that institutions will have and need. It will ultimately lead to more 
work, not less, and that's exactly where you want to be. In an industry that's 
undergoing growth. 

But even if I'm wrong and I end up becoming a chicken farmer to make ends meet, 
I don't think I'll give up programming. It's a life long love and addiction, 
and I don't think I'm alone in that sentiment. I think many people, which some 
of the best examples are in this book, will keep coding for the sheer love of 
it. It's too late. I've found what I love to do. I'm hooked. I'm a programmer.
